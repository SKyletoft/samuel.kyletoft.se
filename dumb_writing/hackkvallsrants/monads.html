<!DOCTYPE html>
<html>
	<head>
		<title>Why Monads?</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
	</head>
	<body>

<h1>Why Monads?</h1>
<p>So, <i>monads</i> (UK: <i>Monn-add</i>, US: <i>Moe-nadd</i>) are a thing used kinda everywhere in
Functional Programming and beyond, even if people
don't know that what they're working with is a monad
once you leave the FP space.</p>

<h2>What is a monad?</h2>
<p>A monad is a container that can have a neutral (empty) state and a set
of operations on the things that maybe exist within it.</p>

<h2>What?</h2>
<p>Let's start with a list and function called <code>map</code>.</p>

<pre>
  myList = [1,2,3,4] :: [Int]
  someFunction = λx → x + 1 :: Int → Int

  $ map someFunction myList
  > [2,3,4,5]
</pre>

<p>Hopefully you've <code>seen</code> map before. Now consider a special list that can
at most take one element:</p>

<pre>
  data MaxOneList α
    = One α
    | Empty
</pre>

<p>Surely map should work on this list too.</p>
<pre>
  map :: (α → β) → MaxOneList α → MaxOneList β
  map _ Empty   = Empty
  map f (One x) = One (f x)
</pre>

<p>Now a list of max one element might seem like a dumb idea, but that's
essentially what a <code>Maybe</code> or an <code>Option</code> is.</p>

<pre>
  data MaxOneList α │ data Maybe α │ data Option
    = One α         │   = Just α   │   = Some α
    | Empty         │   | Nothing  │   | None
</pre>

<p>So clearly map is a function that should operate over a greater set of
types than just the simple list. In the haskell world we call this set
of types Functors and the interface is just that simple.</p>

<pre>
  class Functor container where
    fmap :: (α → β) → container α → container β
</pre>

<p>Now we can write code that is generic over any container that has α
reasonable implementation of <code>map</code>.</p>

<p>Now, skipping over some details (Applicative) the other two
important interfaces are return and bind (also
called <code>and_then</code>).</p>

<pre>
  class Monad container where
    return :: α → container α
    bind   :: container α → (α → container β) → container β
</pre>

<p>(<code>Bind</code> is usually spelled <code>>>=</code>.)</p>
<p><code>Return</code> just wraps the element in the container.</p>

<pre>
  $ return x :: Maybe α
  > Just x

  $ return x :: [α]
  > [x]
</pre>

<p><code>Bind</code> however is the more interesting part. In the case
of <code>Maybe</code> you might and an element and you have a function
that might give you a result.</p>

<pre>
  $ bind (Just 2) (λx → Just (x + 1))
  > Just 3
</pre>

<p><code>Bind</code> is essentially just a flattened <code>fmap</code>.</p>

<pre>
  flatten :: Maybe (Maybe α) → Maybe α
  flatten (Just (Just x) = Just x
  flatten _              = Nothing

  bind :: Maybe α → (α → Maybe β) → Maybe β
  bind Nothing _  = Nothing
  bind (Just x) f = f x

  <=>

  bind x f = flatten (fmap f x)
</pre>

For lists flatten is called <code>concat</code> and works like this:
<pre>
  $ concat [[1, 2], [3], [4], [5, 6, 7]
  > [1, 2, 3, 4, 5, 6, 7]
</pre>

<p>You might've seen <code>flatMap</code> or <code>concatMap</code>. They're <code>bind</code>!</p>

<p>And that's all a monad is, a generic interface with these operations.</p>

<h2>So, why?</h2>


<h2>Sidestory: Applicative</h2>

Next we have another interface that builds upon Functor called
Applicative. It's similar to (f)map but we also keep the function in
the container and has a way to wrap an element in a container.

<pre>
  class Functor container ⇒ Applicative container where
    pure :: α → container α
    <*>  :: container (α → β) → container α → container β
</pre>

It using it looks like this:

<pre>
  f = λx → x + 1

  $ pure x
  > Just x

  $ pure f <*> pure 1 :: Maybe Int
  > Just 2

  $ Nothing <*> Just 1
  > Nothing

  $ Just f <*> Nothing
  > Nothing

  $ [f, g] <*> [x, y]
  > [f x, f y, g x, g y]
</pre>


		<!-- https://thebestmotherfucking.website/main.css -->
		<link rel="stylesheet" href="style.css">
		<style>
			code, pre {
				background-color: #F0F0F0;
				border-radius: 5px;
			}
		</style>
	</body>
</html>
